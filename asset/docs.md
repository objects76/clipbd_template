이 영상은 일반적인 소프트웨어 엔지니어링 원칙을 적용하여 신뢰성 높은 AI 에이전트를 구축하는 방법을 설명합니다. 발표자는 기존 프레임워크 중심의 개발 방식이 겪는 한계를 지적하며, 개발자가 직접 제어 흐름과 상태를 관리하는 'AI 에이전트의 12가지 요소'라는 개념을 통해 80% 이상의 품질을 달성하는 방법을 제시합니다.

-----

## 단계별 가이드

* **[[03:53]](https://www.youtube.com/watch?v=8kMaTybvDUw&t=233s) 요소 1 & 4: JSON 출력 및 도구 사용에 대한 재정의**
  LLM의 가장 강력한 기능은 자연어 문장을 **JSON** 형식으로 변환하는 것입니다. '도구 사용(Tool Use)'이란 신비한 과정이 아니라, LLM이 특정 작업을 지시하는 JSON을 출력하면, 개발자가 작성한 결정론적 코드(예: `switch` 문)가 이를 받아 실행하는 과정일 뿐입니다.

* **[[05:09]](https://www.youtube.com/watch?v=8kMaTybvDUw&t=309s) 요소 8: 제어 흐름의 소유**
  단순히 LLM이 다음 단계를 결정하게 두는 간단한 루프(loop) 구조는 컨텍스트 창이 길어지면 안정성이 떨어집니다. 대신 개발자가 직접 에이전트의 루프, 컨텍스트 창 관리, 종료 조건 등 \*\*제어 흐름(Control Flow)\*\*을 소유하고 코드로 명시적으로 관리해야 합니다.

* **[[07:22]](https://www.youtube.com/watch?v=8kMaTybvDUw&t=442s) 실행 상태 관리 (일시정지 및 재개)**
  제어 흐름을 직접 관리하면 에이전트의 상태를 직렬화(serialize)하여 데이터베이스에 저장할 수 있습니다. 이를 통해 시간이 오래 걸리는 작업을 위해 워크플로우를 **일시정지**했다가, 작업이 완료되면 다시 상태를 불러와 **재개**하는 등 일반적인 소프트웨어처럼 유연하게 에이전트를 다룰 수 있습니다.

* **[[08:37]](https://www.youtube.com/watch?v=8kMaTybvDUw&t=517s) 요소 2: 프롬프트와 컨텍스트 창의 소유**
  높은 신뢰도를 위해서는 LLM에 입력되는 모든 토큰을 직접 제어해야 합니다. 프레임워크가 자동으로 생성해주는 것에 의존하기보다, 직접 **프롬프트**를 작성하고 컨텍스트 창이 어떻게 구성되는지를 완벽하게 **소유**해야 합니다. 단순히 대화 기록을 추가하는 것을 넘어, 정보의 밀도와 명확성을 최적화해야 합니다.

* **[[10:40]](https://www.youtube.com/watch?v=8kMaTybvDUw&t=640s) 오류 처리 방식**
  모델이 잘못된 API를 호출하는 등 오류가 발생했을 때, 오류 메시지를 무작정 컨텍스트 창에 추가하면 모델이 혼란에 빠질 수 있습니다. 오류를 요약하거나, 성공적인 도구 호출이 발생하면 이전 오류 기록을 삭제하는 등 **컨텍스트를 신중하게 관리**해야 합니다.

* **[[11:20]](https://www.youtube.com/watch?v=8kMaTybvDUw&t=680s) 인간과의 상호작용을 도구로 취급하기**
  모델이 '도구 호출'과 '사용자에게 메시지 보내기' 중 하나를 선택하게 하는 대신, **인간과의 대화 자체를 하나의 도구**로 취급하는 것이 좋습니다. 이를 통해 모델이 자연어 토큰을 생성하며 의도를 더 명확하게 표현할 수 있습니다.

* **[[12:31]](https://www.youtube.com/watch?v=8kMaTybvDUw&t=751s) 작고 집중된 '마이크로 에이전트' 활용**
  하나의 거대한 에이전트가 모든 것을 처리하게 하는 대신, 대부분 결정론적인 워크플로우(DAG) 내에서 특정하고 작은 작업을 수행하는 여러 개의 \*\*마이크로 에이전트(Micro Agents)\*\*를 사용하는 것이 훨씬 안정적입니다. 예를 들어, 전체 배포 파이프라인 중 사람의 승인이 필요한 특정 단계만 에이전트에게 맡기는 방식입니다.

* **[[14:34]](https://www.youtube.com/watch?v=8kMaTybvDUw&t=874s) 상태 없는(Stateless) 에이전트**
  에이전트 자체는 **상태가 없는 순수 함수**처럼 설계해야 합니다. 모든 상태(state)는 에이전트 외부의 애플리케이션 코드에서 명시적으로 관리되어야 예측 가능성과 테스트 용이성이 높아집니다.

-----

## 핵심 팁과 모범 사례

* **에이전트를 소프트웨어처럼 다루세요:** AI 에이전트도 결국 소프트웨어입니다. 기존의 소프트웨어 엔지니어링 원칙(제어 흐름, 상태 관리 등)을 동일하게 적용해야 합니다.
* **컨텍스트 엔지니어링에 집중하세요:** 에이전트의 성능은 컨텍스트 창에 어떤 토큰을 넣느냐에 따라 결정됩니다. 프롬프트, 메모리, RAG 결과 등 모든 요소를 신중하게 설계하고 최적화해야 합니다.
* **'마이크로 에이전트' 아키텍처를 채택하세요:** 하나의 만능 에이전트 대신, 작고 명확한 책임을 가진 여러 에이전트를 조합하여 더 크고 복잡한 시스템을 구축하는 것이 안정적입니다.
* **인간을 루프에 포함시키세요:** 에이전트가 사람과 협업할 수 있는 경로를 만드세요. 이메일, 슬랙 등 사용자가 이미 있는 곳에서 에이전트가 작동하게 하고, 필요할 때 사람의 개입을 요청하도록 설계하는 것이 효과적입니다.

-----

## 기술 용어

* **AI 에이전트 (AI Agent):** 목표를 달성하기 위해 도구를 사용하고, 계획을 세우며, 루프 안에서 자율적으로 행동할 수 있는 LLM 기반 시스템입니다.
* **제어 흐름 (Control Flow):** 프로그램의 명령문, 함수 호출 등이 실행되는 순서입니다. 발표자는 개발자가 이 흐름을 직접 코드로 제어해야 한다고 강조합니다.
* **컨텍스트 창 (Context Window):** LLM에 입력되는 모든 정보(프롬프트, 대화 기록, 도구 사용 결과 등)를 담는 공간입니다. 이 공간을 효율적으로 관리하는 것이 에이전트 신뢰도의 핵심입니다.
* **마이크로 에이전트 (Micro Agents):** 더 큰 결정론적 워크플로우 내에서 제한된 특정 작업을 수행하도록 설계된 작고 전문화된 에이전트입니다.

-----

## 결론 및 결과

## 이 가이드에서 제시된 원칙들을 따르면 개발자는 일반적인 성능 한계를 넘어, **더 신뢰성 있고 예측 가능한 AI 에이전트를 구축**할 수 있습니다. 핵심은 프레임워크의 '마법'에 의존하는 대신, 제어 흐름과 상태 관리를 포함한 시스템의 모든 측면을 개발자가 직접 소유하는 것입니다. 이를 통해 시스템에 신뢰성을 주입하고, 정말 중요한 AI 관련 문제(프롬프트, 컨텍스트 엔지니어링)에 집중하여 차별화된 결과물을 만들 수 있습니다.
